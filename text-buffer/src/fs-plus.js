// Generated by CoffeeScript 2.6.1
var BINARY_EXTENSIONS, COMPRESSED_EXTENSIONS, IMAGE_EXTENSIONS, MARKDOWN_EXTENSIONS, Module, _, async, checkIfElectron2OrLower, fs, fsPlus, isElectron2OrLower, isMoveTargetValid, isMoveTargetValidSync, isPathValid, lstatSyncNoException, mkdirp, path, rimraf, statSyncNoException;

fs = require('fs');

Module = require('module');

path = require('path');

_ = require('underscore-plus');

async = require('async');

mkdirp = require('mkdirp');

rimraf = require('rimraf');

// Public: Useful extensions to node's built-in fs module

// Important, this extends Node's builtin in ['fs' module][fs], which means that you
// can do anything that you can do with Node's 'fs' module plus a few extra
// functions that we've found to be helpful.

// [fs]: http://nodejs.org/api/fs.html
fsPlus = {
  __esModule: false,
  getHomeDirectory: function() {
    if (process.platform === 'win32' && !process.env.HOME) {
      return process.env.USERPROFILE;
    } else {
      return process.env.HOME;
    }
  },
  // Public: Make the given path absolute by resolving it against the current
  // working directory.

  // relativePath - The {String} containing the relative path. If the path is
  //                prefixed with '~', it will be expanded to the current user's
  //                home directory.

  // Returns the {String} absolute path or the relative path if it's unable to
  // determine its real path.
  absolute: function(relativePath) {
    var e;
    if (relativePath == null) {
      return null;
    }
    relativePath = fsPlus.resolveHome(relativePath);
    try {
      return fs.realpathSync(relativePath);
    } catch (error1) {
      e = error1;
      return relativePath;
    }
  },
  // Public: Normalize the given path treating a leading `~` segment as referring
  // to the home directory. This method does not query the filesystem.

  // pathToNormalize - The {String} containing the abnormal path. If the path is
  //                   prefixed with '~', it will be expanded to the current
  //                   user's home directory.

  // Returns a normalized path {String}.
  normalize: function(pathToNormalize) {
    if (pathToNormalize == null) {
      return null;
    }
    return fsPlus.resolveHome(path.normalize(pathToNormalize.toString()));
  },
  resolveHome: function(relativePath) {
    if (relativePath === '~') {
      return fsPlus.getHomeDirectory();
    } else if (relativePath.indexOf(`~${path.sep}`) === 0) {
      return `${fsPlus.getHomeDirectory()}${relativePath.substring(1)}`;
    }
    return relativePath;
  },
  // Public: Convert an absolute path to tilde path for Linux and macOS.
  // /Users/username/dev => ~/dev

  // pathToTildify - The {String} containing the full path.

  // Returns a tildified path {String}.
  tildify: function(pathToTildify) {
    var homeDir, normalized;
    if (process.platform === 'win32') {
      return pathToTildify;
    }
    normalized = fsPlus.normalize(pathToTildify);
    homeDir = fsPlus.getHomeDirectory();
    if (homeDir == null) {
      return pathToTildify;
    }
    if (normalized === homeDir) {
      return '~';
    }
    if (!normalized.startsWith(path.join(homeDir, path.sep))) {
      return pathToTildify;
    }
    return path.join('~', path.sep, normalized.substring(homeDir.length + 1));
  },
  // Public: Get path to store application specific data.

  // Returns the {String} absolute path or null if platform isn't supported
  // Mac: ~/Library/Application Support/
  // Win: %AppData%
  // Linux: /var/lib
  getAppDataDirectory: function() {
    switch (process.platform) {
      case 'darwin':
        return fsPlus.absolute(path.join('~', 'Library', 'Application Support'));
      case 'linux':
        return '/var/lib';
      case 'win32':
        return process.env.APPDATA;
      default:
        return null;
    }
  },
  // Public: Is the given path absolute?

  // pathToCheck - The relative or absolute {String} path to check.

  // Returns a {Boolean}, true if the path is absolute, false otherwise.
  isAbsolute: function(pathToCheck = '') {
    if (process.platform === 'win32') {
      if (pathToCheck[1] === ':') { // C:\ style
        return true;
      }
      if (pathToCheck[0] === '\\' && pathToCheck[1] === '\\') { // \\server\share style
        return true;
      }
    } else {
      return pathToCheck[0] === '/'; // /usr style
    }
    return false;
  },
  // Public: Returns true if a file or folder at the specified path exists.
  existsSync: function(pathToCheck) {
    return isPathValid(pathToCheck) && (statSyncNoException(pathToCheck) !== false);
  },
  // Public: Returns true if the given path exists and is a directory.
  isDirectorySync: function(directoryPath) {
    var stat;
    if (!isPathValid(directoryPath)) {
      return false;
    }
    if (stat = statSyncNoException(directoryPath)) {
      return stat.isDirectory();
    } else {
      return false;
    }
  },
  // Public: Asynchronously checks that the given path exists and is a directory.
  isDirectory: function(directoryPath, done) {
    if (!isPathValid(directoryPath)) {
      return done(false);
    }
    return fs.stat(directoryPath, function(error, stat) {
      if (error != null) {
        return done(false);
      } else {
        return done(stat.isDirectory());
      }
    });
  },
  // Public: Returns true if the specified path exists and is a file.
  isFileSync: function(filePath) {
    var stat;
    if (!isPathValid(filePath)) {
      return false;
    }
    if (stat = statSyncNoException(filePath)) {
      return stat.isFile();
    } else {
      return false;
    }
  },
  // Public: Returns true if the specified path is a symbolic link.
  isSymbolicLinkSync: function(symlinkPath) {
    var stat;
    if (!isPathValid(symlinkPath)) {
      return false;
    }
    if (stat = lstatSyncNoException(symlinkPath)) {
      return stat.isSymbolicLink();
    } else {
      return false;
    }
  },
  // Public: Calls back with true if the specified path is a symbolic link.
  isSymbolicLink: function(symlinkPath, callback) {
    if (isPathValid(symlinkPath)) {
      return fs.lstat(symlinkPath, function(error, stat) {
        return typeof callback === "function" ? callback((stat != null) && stat.isSymbolicLink()) : void 0;
      });
    } else {
      return process.nextTick(function() {
        return typeof callback === "function" ? callback(false) : void 0;
      });
    }
  },
  // Public: Returns true if the specified path is executable.
  isExecutableSync: function(pathToCheck) {
    var stat;
    if (!isPathValid(pathToCheck)) {
      return false;
    }
    if (stat = statSyncNoException(pathToCheck)) {
      return (stat.mode & 0o777 & 1) !== 0;
    } else {
      return false;
    }
  },
  // Public: Returns the size of the specified path.
  getSizeSync: function(pathToCheck) {
    var ref;
    if (isPathValid(pathToCheck)) {
      return (ref = statSyncNoException(pathToCheck).size) != null ? ref : -1;
    } else {
      return -1;
    }
  },
  // Public: Returns an Array with the paths of the files and directories
  // contained within the directory path. It is not recursive.

  // rootPath - The absolute {String} path to the directory to list.
  // extensions - An {Array} of extensions to filter the results by. If none are
  //              given, none are filtered (optional).
  listSync: function(rootPath, extensions) {
    var paths;
    if (!fsPlus.isDirectorySync(rootPath)) {
      return [];
    }
    paths = fs.readdirSync(rootPath);
    if (extensions) {
      paths = fsPlus.filterExtensions(paths, extensions);
    }
    paths = paths.sort(function(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    });
    paths = paths.map(function(childPath) {
      return path.join(rootPath, childPath);
    });
    return paths;
  },
  // Public: Asynchronously lists the files and directories in the given path.
  // The listing is not recursive.

  // rootPath - The absolute {String} path to the directory to list.
  // extensions - An {Array} of extensions to filter the results by. If none are
  //              given, none are filtered (optional).
  // callback - The {Function} to call.
  list: function(rootPath, ...rest) {
    var done, extensions;
    if (rest.length > 1) {
      extensions = rest.shift();
    }
    done = rest.shift();
    return fs.readdir(rootPath, function(error, paths) {
      if (error != null) {
        return done(error);
      } else {
        if (extensions) {
          paths = fsPlus.filterExtensions(paths, extensions);
        }
        paths = paths.sort(function(a, b) {
          return a.toLowerCase().localeCompare(b.toLowerCase());
        });
        paths = paths.map(function(childPath) {
          return path.join(rootPath, childPath);
        });
        return done(null, paths);
      }
    });
  },
  // Returns only the paths which end with one of the given extensions.
  filterExtensions: function(paths, extensions) {
    extensions = extensions.map(function(ext) {
      if (ext === '') {
        return ext;
      } else {
        return '.' + ext.replace(/^\./, '');
      }
    });
    return paths.filter(function(pathToCheck) {
      return _.include(extensions, path.extname(pathToCheck));
    });
  },
  // Public: Get all paths under the given path.

  // rootPath - The {String} path to start at.

  // Return an {Array} of {String}s under the given path.
  listTreeSync: function(rootPath) {
    var onPath, paths;
    paths = [];
    onPath = function(childPath) {
      paths.push(childPath);
      return true;
    };
    fsPlus.traverseTreeSync(rootPath, onPath, onPath);
    return paths;
  },
  // Public: Moves the source file or directory to the target asynchronously.
  move: function(source, target, callback) {
    return isMoveTargetValid(source, target, function(isMoveTargetValidErr, isTargetValid) {
      var error, targetParentPath;
      if (isMoveTargetValidErr) {
        callback(isMoveTargetValidErr);
        return;
      }
      if (!isTargetValid) {
        error = new Error(`'${target}' already exists.`);
        error.code = 'EEXIST';
        callback(error);
        return;
      }
      targetParentPath = path.dirname(target);
      return fs.exists(targetParentPath, function(targetParentExists) {
        if (targetParentExists) {
          fs.rename(source, target, callback);
          return;
        }
        return fsPlus.makeTree(targetParentPath, function(makeTreeErr) {
          if (makeTreeErr) {
            callback(makeTreeErr);
            return;
          }
          return fs.rename(source, target, callback);
        });
      });
    });
  },
  // Public: Moves the source file or directory to the target synchronously.
  moveSync: function(source, target) {
    var error, targetParentPath;
    if (!isMoveTargetValidSync(source, target)) {
      error = new Error(`'${target}' already exists.`);
      error.code = 'EEXIST';
      throw error;
    }
    targetParentPath = path.dirname(target);
    if (!fs.existsSync(targetParentPath)) {
      fsPlus.makeTreeSync(targetParentPath);
    }
    return fs.renameSync(source, target);
  },
  // Public: Removes the file or directory at the given path synchronously.
  removeSync: function(pathToRemove) {
    return rimraf.sync(pathToRemove);
  },
  // Public: Removes the file or directory at the given path asynchronously.
  remove: function(pathToRemove, callback) {
    return rimraf(pathToRemove, callback);
  },
  // Public: Open, write, flush, and close a file, writing the given content
  // synchronously.

  // It also creates the necessary parent directories.
  writeFileSync: function(filePath, content, options) {
    mkdirp.sync(path.dirname(filePath));
    return fs.writeFileSync(filePath, content, options);
  },
  // Public: Open, write, flush, and close a file, writing the given content
  // asynchronously.

  // It also creates the necessary parent directories.
  writeFile: function(filePath, content, options, callback) {
    callback = _.last(arguments);
    return mkdirp(path.dirname(filePath), function(error) {
      if (error != null) {
        return typeof callback === "function" ? callback(error) : void 0;
      } else {
        return fs.writeFile(filePath, content, options, callback);
      }
    });
  },
  // Public: Copies the given path asynchronously.
  copy: function(sourcePath, destinationPath, done) {
    return mkdirp(path.dirname(destinationPath), function(error) {
      var destinationStream, sourceStream;
      if (error != null) {
        if (typeof done === "function") {
          done(error);
        }
        return;
      }
      sourceStream = fs.createReadStream(sourcePath);
      sourceStream.on('error', function(error) {
        if (typeof done === "function") {
          done(error);
        }
        return done = null;
      });
      destinationStream = fs.createWriteStream(destinationPath);
      destinationStream.on('error', function(error) {
        if (typeof done === "function") {
          done(error);
        }
        return done = null;
      });
      destinationStream.on('close', function() {
        if (typeof done === "function") {
          done();
        }
        return done = null;
      });
      return sourceStream.pipe(destinationStream);
    });
  },
  // Public: Copies the given path recursively and synchronously.
  copySync: function(sourcePath, destinationPath) {
    var destinationFilePath, i, len, results, source, sourceFilePath, sources;
    // We need to save the sources before creaing the new directory to avoid
    // infinitely creating copies of the directory when copying inside itself
    sources = fs.readdirSync(sourcePath);
    mkdirp.sync(destinationPath);
    results = [];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      sourceFilePath = path.join(sourcePath, source);
      destinationFilePath = path.join(destinationPath, source);
      if (fsPlus.isDirectorySync(sourceFilePath)) {
        results.push(fsPlus.copySync(sourceFilePath, destinationFilePath));
      } else {
        results.push(fsPlus.copyFileSync(sourceFilePath, destinationFilePath));
      }
    }
    return results;
  },
  // Public: Copies the given path synchronously, buffering reads and writes to
  // keep memory footprint to a minimum. If the destination directory doesn't
  // exist, it creates it.

  // * sourceFilePath - A {String} representing the file path you want to copy.
  // * destinationFilePath - A {String} representing the file path where the file will be copied.
  // * bufferSize - An {Integer} representing the size in bytes of the buffer
  //   when reading from and writing to disk. The default is 16KB.
  copyFileSync: function(sourceFilePath, destinationFilePath, bufferSize = 16 * 1024) {
    var buffer, bytesRead, position, readFd, results, writeFd;
    mkdirp.sync(path.dirname(destinationFilePath));
    readFd = null;
    writeFd = null;
    try {
      readFd = fs.openSync(sourceFilePath, 'r');
      writeFd = fs.openSync(destinationFilePath, 'w');
      bytesRead = 1;
      position = 0;
      results = [];
      while (bytesRead > 0) {
        buffer = new Buffer(bufferSize);
        bytesRead = fs.readSync(readFd, buffer, 0, buffer.length, position);
        fs.writeSync(writeFd, buffer, 0, bytesRead, position);
        results.push(position += bytesRead);
      }
      return results;
    } finally {
      if (readFd != null) {
        fs.closeSync(readFd);
      }
      if (writeFd != null) {
        fs.closeSync(writeFd);
      }
    }
  },
  // Public: Create a directory at the specified path including any missing
  // parent directories synchronously.
  makeTreeSync: function(directoryPath) {
    if (!fsPlus.isDirectorySync(directoryPath)) {
      return mkdirp.sync(directoryPath);
    }
  },
  // Public: Create a directory at the specified path including any missing
  // parent directories asynchronously.
  makeTree: function(directoryPath, callback) {
    return fsPlus.isDirectory(directoryPath, function(exists) {
      if (exists) {
        return typeof callback === "function" ? callback() : void 0;
      }
      return mkdirp(directoryPath, function(error) {
        return typeof callback === "function" ? callback(error) : void 0;
      });
    });
  },
  // Public: Recursively walk the given path and execute the given functions
  // synchronously.

  // rootPath - The {String} containing the directory to recurse into.
  // onFile - The {Function} to execute on each file, receives a single argument
  //          the absolute path.
  // onDirectory - The {Function} to execute on each directory, receives a single
  //               argument the absolute path (defaults to onFile). If this
  //               function returns a falsy value then the directory is not
  //               entered.
  traverseTreeSync: function(rootPath, onFile, onDirectory = onFile) {
    var traverse;
    if (!fsPlus.isDirectorySync(rootPath)) {
      return;
    }
    traverse = function(directoryPath, onFile, onDirectory) {
      var childPath, file, i, len, linkStats, ref, stats;
      ref = fs.readdirSync(directoryPath);
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        childPath = path.join(directoryPath, file);
        stats = fs.lstatSync(childPath);
        if (stats.isSymbolicLink()) {
          if (linkStats = statSyncNoException(childPath)) {
            stats = linkStats;
          }
        }
        if (stats.isDirectory()) {
          if (onDirectory(childPath)) {
            traverse(childPath, onFile, onDirectory);
          }
        } else if (stats.isFile()) {
          onFile(childPath);
        }
      }
      return void 0;
    };
    return traverse(rootPath, onFile, onDirectory);
  },
  // Public: Recursively walk the given path and execute the given functions
  // asynchronously.

  // rootPath - The {String} containing the directory to recurse into.
  // onFile - The {Function} to execute on each file, receives a single argument
  //          the absolute path.
  // onDirectory - The {Function} to execute on each directory, receives a single
  //               argument the absolute path (defaults to onFile).
  traverseTree: function(rootPath, onFile, onDirectory, onDone) {
    return fs.readdir(rootPath, function(error, files) {
      var file, i, len, queue, results;
      if (error) {
        return typeof onDone === "function" ? onDone() : void 0;
      } else {
        queue = async.queue(function(childPath, callback) {
          return fs.stat(childPath, function(error, stats) {
            if (error) {
              return callback(error);
            } else if (stats.isFile()) {
              onFile(childPath);
              return callback();
            } else if (stats.isDirectory()) {
              if (onDirectory(childPath)) {
                return fs.readdir(childPath, function(error, files) {
                  var file, i, len;
                  if (error) {
                    return callback(error);
                  } else {
                    for (i = 0, len = files.length; i < len; i++) {
                      file = files[i];
                      queue.unshift(path.join(childPath, file));
                    }
                    return callback();
                  }
                });
              } else {
                return callback();
              }
            } else {
              return callback();
            }
          });
        });
        queue.concurrency = 1;
        queue.drain = onDone;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(queue.push(path.join(rootPath, file)));
        }
        return results;
      }
    });
  },
  // Public: Hashes the contents of the given file.

  // pathToDigest - The {String} containing the absolute path.

  // Returns a String containing the MD5 hexadecimal hash.
  md5ForPath: function(pathToDigest) {
    var contents;
    contents = fs.readFileSync(pathToDigest);
    return require('crypto').createHash('md5').update(contents).digest('hex');
  },
  // Public: Finds a relative path among the given array of paths.

  // loadPaths - An {Array} of absolute and relative paths to search.
  // pathToResolve - The {String} containing the path to resolve.
  // extensions - An {Array} of extensions to pass to {resolveExtensions} in
  //              which case pathToResolve should not contain an extension
  //              (optional).

  // Returns the absolute path of the file to be resolved if it's found and
  // undefined otherwise.
  resolve: function(...args) {
    var candidatePath, extensions, i, len, loadPath, loadPaths, pathToResolve, ref, resolvedPath;
    if (_.isArray(_.last(args))) {
      extensions = args.pop();
    }
    pathToResolve = (ref = args.pop()) != null ? ref.toString() : void 0;
    loadPaths = args;
    if (!pathToResolve) {
      return void 0;
    }
    if (fsPlus.isAbsolute(pathToResolve)) {
      if (extensions && (resolvedPath = fsPlus.resolveExtension(pathToResolve, extensions))) {
        return resolvedPath;
      } else {
        if (fsPlus.existsSync(pathToResolve)) {
          return pathToResolve;
        }
      }
    }
    for (i = 0, len = loadPaths.length; i < len; i++) {
      loadPath = loadPaths[i];
      candidatePath = path.join(loadPath, pathToResolve);
      if (extensions) {
        if (resolvedPath = fsPlus.resolveExtension(candidatePath, extensions)) {
          return resolvedPath;
        }
      } else {
        if (fsPlus.existsSync(candidatePath)) {
          return fsPlus.absolute(candidatePath);
        }
      }
    }
    return void 0;
  },
  // Public: Like {.resolve} but uses node's modules paths as the load paths to
  // search.
  resolveOnLoadPath: function(...args) {
    var loadPaths, modulePaths;
    modulePaths = null;
    if (module.paths != null) {
      modulePaths = module.paths;
    } else if (process.resourcesPath) {
      modulePaths = [path.join(process.resourcesPath, 'app', 'node_modules')];
    } else {
      modulePaths = [];
    }
    loadPaths = Module.globalPaths.concat(modulePaths);
    return fsPlus.resolve(...loadPaths, ...args);
  },
  // Public: Finds the first file in the given path which matches the extension
  // in the order given.

  // pathToResolve - The {String} containing relative or absolute path of the
  //                 file in question without the extension or '.'.
  // extensions - The ordered {Array} of extensions to try.

  // Returns the absolute path of the file if it exists with any of the given
  // extensions, otherwise it's undefined.
  resolveExtension: function(pathToResolve, extensions) {
    var extension, i, len, pathWithExtension;
    for (i = 0, len = extensions.length; i < len; i++) {
      extension = extensions[i];
      if (extension === "") {
        if (fsPlus.existsSync(pathToResolve)) {
          return fsPlus.absolute(pathToResolve);
        }
      } else {
        pathWithExtension = pathToResolve + "." + extension.replace(/^\./, "");
        if (fsPlus.existsSync(pathWithExtension)) {
          return fsPlus.absolute(pathWithExtension);
        }
      }
    }
    return void 0;
  },
  // Public: Returns true for extensions associated with compressed files.
  isCompressedExtension: function(ext) {
    if (ext == null) {
      return false;
    }
    return COMPRESSED_EXTENSIONS.hasOwnProperty(ext.toLowerCase());
  },
  // Public: Returns true for extensions associated with image files.
  isImageExtension: function(ext) {
    if (ext == null) {
      return false;
    }
    return IMAGE_EXTENSIONS.hasOwnProperty(ext.toLowerCase());
  },
  // Public: Returns true for extensions associated with pdf files.
  isPdfExtension: function(ext) {
    return (ext != null ? ext.toLowerCase() : void 0) === '.pdf';
  },
  // Public: Returns true for extensions associated with binary files.
  isBinaryExtension: function(ext) {
    if (ext == null) {
      return false;
    }
    return BINARY_EXTENSIONS.hasOwnProperty(ext.toLowerCase());
  },
  // Public: Returns true for files named similarily to 'README'
  isReadmePath: function(readmePath) {
    var base, extension;
    extension = path.extname(readmePath);
    base = path.basename(readmePath, extension).toLowerCase();
    return base === 'readme' && (extension === '' || fsPlus.isMarkdownExtension(extension));
  },
  // Public: Returns true for extensions associated with Markdown files.
  isMarkdownExtension: function(ext) {
    if (ext == null) {
      return false;
    }
    return MARKDOWN_EXTENSIONS.hasOwnProperty(ext.toLowerCase());
  },
  // Public: Is the filesystem case insensitive?

  // Returns `true` if case insensitive, `false` otherwise.
  isCaseInsensitive: function() {
    var lowerCaseStat, upperCaseStat;
    if (fsPlus.caseInsensitiveFs == null) {
      lowerCaseStat = statSyncNoException(process.execPath.toLowerCase());
      upperCaseStat = statSyncNoException(process.execPath.toUpperCase());
      if (lowerCaseStat && upperCaseStat) {
        fsPlus.caseInsensitiveFs = lowerCaseStat.dev === upperCaseStat.dev && lowerCaseStat.ino === upperCaseStat.ino;
      } else {
        fsPlus.caseInsensitiveFs = false;
      }
    }
    return fsPlus.caseInsensitiveFs;
  },
  // Public: Is the filesystem case sensitive?

  // Returns `true` if case sensitive, `false` otherwise.
  isCaseSensitive: function() {
    return !fsPlus.isCaseInsensitive();
  },
  // Public: Calls `fs.statSync`, catching all exceptions raised. This
  // method calls `fs.statSyncNoException` when provided by the underlying
  // `fs` module (Electron < 3.0).

  // Returns `fs.Stats` if the file exists, `false` otherwise.
  statSyncNoException: function(...args) {
    return statSyncNoException(...args);
  },
  // Public: Calls `fs.lstatSync`, catching all exceptions raised.  This
  // method calls `fs.lstatSyncNoException` when provided by the underlying
  // `fs` module (Electron < 3.0).

  // Returns `fs.Stats` if the file exists, `false` otherwise.
  lstatSyncNoException: function(...args) {
    return lstatSyncNoException(...args);
  }
};

// Built-in [l]statSyncNoException methods are only provided in Electron releases
// before 3.0.  We delay the version check until first request so that Electron
// application snapshots can be generated successfully.
isElectron2OrLower = null;

checkIfElectron2OrLower = function() {
  if (isElectron2OrLower === null) {
    isElectron2OrLower = process.versions.electron && parseInt(process.versions.electron.split('.')[0]) <= 2;
  }
  return isElectron2OrLower;
};

statSyncNoException = function(...args) {
  var error;
  if (fs.statSyncNoException && checkIfElectron2OrLower()) {
    return fs.statSyncNoException(...args);
  } else {
    try {
      return fs.statSync(...args);
    } catch (error1) {
      error = error1;
      return false;
    }
  }
};

lstatSyncNoException = function(...args) {
  var error;
  if (fs.lstatSyncNoException && checkIfElectron2OrLower()) {
    return fs.lstatSyncNoException(...args);
  } else {
    try {
      return fs.lstatSync(...args);
    } catch (error1) {
      error = error1;
      return false;
    }
  }
};

BINARY_EXTENSIONS = {
  '.ds_store': true,
  '.a': true,
  '.exe': true,
  '.o': true,
  '.pyc': true,
  '.pyo': true,
  '.so': true,
  '.woff': true
};

COMPRESSED_EXTENSIONS = {
  '.bz2': true,
  '.egg': true,
  '.epub': true,
  '.gem': true,
  '.gz': true,
  '.jar': true,
  '.lz': true,
  '.lzma': true,
  '.lzo': true,
  '.rar': true,
  '.tar': true,
  '.tgz': true,
  '.war': true,
  '.whl': true,
  '.xpi': true,
  '.xz': true,
  '.z': true,
  '.zip': true
};

IMAGE_EXTENSIONS = {
  '.gif': true,
  '.ico': true,
  '.jpeg': true,
  '.jpg': true,
  '.png': true,
  '.tif': true,
  '.tiff': true,
  '.webp': true
};

MARKDOWN_EXTENSIONS = {
  '.markdown': true,
  '.md': true,
  '.mdown': true,
  '.mkd': true,
  '.mkdown': true,
  '.rmd': true,
  '.ron': true
};

isPathValid = function(pathToCheck) {
  return (pathToCheck != null) && typeof pathToCheck === 'string' && pathToCheck.length > 0;
};

isMoveTargetValid = function(source, target, callback) {
  return fs.stat(source, function(oldErr, oldStat) {
    if (oldErr) {
      callback(oldErr);
      return;
    }
    return fs.stat(target, function(newErr, newStat) {
      if (newErr && newErr.code === 'ENOENT') {
        callback(void 0, true); // new path does not exist so it is valid
        return;
      }
      // New path exists so check if it points to the same file as the initial
      // path to see if the case of the file name is being changed on a case
      // insensitive filesystem.
      return callback(void 0, source.toLowerCase() === target.toLowerCase() && oldStat.dev === newStat.dev && oldStat.ino === newStat.ino);
    });
  });
};

isMoveTargetValidSync = function(source, target) {
  var newStat, oldStat;
  oldStat = statSyncNoException(source);
  newStat = statSyncNoException(target);
  if (!(oldStat && newStat)) {
    return true;
  }
  // New path exists so check if it points to the same file as the initial
  // path to see if the case of the file name is being changed on a case
  // insensitive filesystem.
  return source.toLowerCase() === target.toLowerCase() && oldStat.dev === newStat.dev && oldStat.ino === newStat.ino;
};

module.exports = new Proxy({}, {
  get: function(target, key) {
    var ref;
    return (ref = fsPlus[key]) != null ? ref : fs[key];
  },
  set: function(target, key, value) {
    return fsPlus[key] = value;
  }
});
